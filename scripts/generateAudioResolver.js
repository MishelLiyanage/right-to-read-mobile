const fs = require('fs');
const path = require('path');

// Read the current BookDataService to see the page structure
const bookDataServicePath = path.join(__dirname, '..', 'services', 'bookDataService.ts');
const bookDataContent = fs.readFileSync(bookDataServicePath, 'utf8');

// Extract page numbers from imports
const pageImports = bookDataContent.match(/grade_3_english_book_page_(\d+)/g);
const pageNumbers = pageImports ? 
  [...new Set(pageImports.map(match => {
    const pageMatch = match.match(/grade_3_english_book_page_(\d+)/);
    return pageMatch ? pageMatch[1] : null;
  }).filter(Boolean))]
    .map(num => parseInt(num))
    .sort((a, b) => a - b) : [];

console.log('Found pages:', pageNumbers.length);

// Generate the audio resolver content
let content = `// Auto-generated AudioResolver service
// This file is generated by scripts/generateAudioResolver.js

`;

// Add all audio imports
pageNumbers.forEach(pageNum => {
  const pageDir = path.join(__dirname, '..', 'data', 'grade_3_english_book', `grade_3_english_book_page_${pageNum}`);
  
  if (fs.existsSync(pageDir)) {
    const audioFiles = fs.readdirSync(pageDir).filter(file => file.endsWith('.mp3'));
    
    if (audioFiles.length > 0) {
      content += `// Page ${pageNum} audio files\n`;
      audioFiles.forEach(file => {
        const blockMatch = file.match(/block_(\d+)_(\d+)_audio\.mp3/);
        if (blockMatch) {
          const blockId = blockMatch[2];
          content += `const page${pageNum}_block${blockId} = require('../data/grade_3_english_book/grade_3_english_book_page_${pageNum}/${file}');\n`;
        }
      });
      content += '\n';
    }
  }
});

// Create audio mappings object
content += `// Audio mappings by page\nconst audioMappings: { [pageNumber: string]: { [blockId: string]: any } } = {\n`;

pageNumbers.forEach(pageNum => {
  const pageDir = path.join(__dirname, '..', 'data', 'grade_3_english_book', `grade_3_english_book_page_${pageNum}`);
  
  if (fs.existsSync(pageDir)) {
    const audioFiles = fs.readdirSync(pageDir).filter(file => file.endsWith('.mp3'));
    
    if (audioFiles.length > 0) {
      content += `  '${pageNum}': {\n`;
      
      audioFiles.forEach(file => {
        const blockMatch = file.match(/block_(\d+)_(\d+)_audio\.mp3/);
        if (blockMatch) {
          const blockId = blockMatch[2];
          content += `    '${blockId}': page${pageNum}_block${blockId},\n`;
        }
      });
      
      content += `  },\n`;
    }
  }
});

content += `};\n\n`;

// Add the service class
content += `export class AudioResolver {
  static resolveAudio(pageNumber: number, blockId: string): any | null {
    const pageAudio = audioMappings[pageNumber.toString()];
    if (!pageAudio) {
      console.log(\`No audio mappings found for page \${pageNumber}\`);
      return null;
    }
    
    const audio = pageAudio[blockId];
    if (!audio) {
      console.log(\`No audio found for page \${pageNumber}, block \${blockId}\`);
      return null;
    }
    
    return audio;
  }
  
  static hasAudioForPage(pageNumber: number): boolean {
    return !!audioMappings[pageNumber.toString()];
  }
  
  static getAvailableBlocksForPage(pageNumber: number): string[] {
    const pageAudio = audioMappings[pageNumber.toString()];
    return pageAudio ? Object.keys(pageAudio) : [];
  }
}
`;

// Write the generated file
const outputPath = path.join(__dirname, '..', 'services', 'AudioResolver.ts');
fs.writeFileSync(outputPath, content);

console.log(`Generated AudioResolver.ts with ${pageNumbers.length} pages`);
console.log('Audio mappings created for pages:', pageNumbers.join(', '));